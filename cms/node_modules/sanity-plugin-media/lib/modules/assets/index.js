"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assetsFetchPageEpic = exports.assetsFetchNextPageEpic = exports.assetsFetchPageIndexEpic = exports.assetsFetchEpic = exports.assetsDeletePickedEpic = exports.assetsDeleteEpic = exports.assetsSetSearchQuery = exports.assetsSetOrder = exports.assetsSetFilter = exports.assetsSetView = exports.assetsPickClear = exports.assetsPickAll = exports.assetsPick = exports.assetsLoadNextPage = exports.assetsLoadPageIndex = exports.assetsFetchError = exports.assetsFetchComplete = exports.assetsFetch = exports.assetsDeletePicked = exports.assetsDeleteError = exports.assetsDeleteComplete = exports.assetsDelete = exports.assetsClear = exports.initialState = exports.AssetsActionTypes = void 0;
var groq_1 = __importDefault(require("groq"));
var immer_1 = __importDefault(require("immer"));
var redux_observable_1 = require("redux-observable");
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var client_1 = __importDefault(require("part:@sanity/base/client"));
var config_1 = require("../../config");
/***********
 * ACTIONS *
 ***********/
var AssetsActionTypes;
(function (AssetsActionTypes) {
    AssetsActionTypes["CLEAR"] = "ASSETS_CLEAR";
    AssetsActionTypes["DELETE_COMPLETE"] = "ASSETS_DELETE_COMPLETE";
    AssetsActionTypes["DELETE_ERROR"] = "ASSETS_DELETE_ERROR";
    AssetsActionTypes["DELETE_PICKED"] = "ASSETS_DELETE_PICKED";
    AssetsActionTypes["DELETE_REQUEST"] = "ASSETS_DELETE_REQUEST";
    AssetsActionTypes["FETCH_COMPLETE"] = "ASSETS_FETCH_COMPLETE";
    AssetsActionTypes["FETCH_ERROR"] = "ASSETS_FETCH_ERROR";
    AssetsActionTypes["FETCH_REQUEST"] = "ASSETS_FETCH_REQUEST";
    AssetsActionTypes["LOAD_NEXT_PAGE"] = "ASSETS_LOAD_NEXT_PAGE";
    AssetsActionTypes["LOAD_PAGE_INDEX"] = "ASSETS_LOAD_PAGE_INDEX";
    AssetsActionTypes["PICK"] = "ASSETS_PICK";
    AssetsActionTypes["PICK_ALL"] = "ASSETS_PICK_ALL";
    AssetsActionTypes["PICK_CLEAR"] = "ASSETS_PICK_CLEAR";
    AssetsActionTypes["SET_FILTER"] = "ASSETS_SET_FILTER";
    AssetsActionTypes["SET_ORDER"] = "ASSETS_SET_ORDER";
    AssetsActionTypes["SET_SEARCH_QUERY"] = "ASSETS_SET_SEARCH_QUERY";
    AssetsActionTypes["SET_VIEW"] = "ASSETS_SET_VIEW";
    AssetsActionTypes["UNCAUGHT_EXCEPTION"] = "ASSETS_UNCAUGHT_EXCEPTION";
})(AssetsActionTypes = exports.AssetsActionTypes || (exports.AssetsActionTypes = {}));
/***********
 * REDUCER *
 ***********/
/**
 * NOTE:
 * `fetchCount` returns the number of items retrieved in the most recent fetch.
 * This is a temporary workaround to be able to determine when there are no more items to retrieve.
 * Typically this would be done by deriving the total number of assets upfront, but currently such
 * queries in GROQ aren't fast enough to use on large datasets (1000s of entries).
 *
 * TODO:
 * When the query engine has been improved and above queries are faster, remove all instances of
 * of `fetchCount` and reinstate `totalCount` across the board.
 */
/**
 * `allIds` is an ordered array of all assetIds
 * `byIds` is an object literal that contains all normalised assets (with asset IDs as keys)
 */
exports.initialState = {
    allIds: [],
    byIds: {},
    fetchCount: -1,
    fetching: false,
    fetchingError: null,
    filter: undefined,
    filters: undefined,
    order: config_1.ORDERS[0],
    pageIndex: 0,
    pageSize: 50,
    searchQuery: '',
    view: 'grid'
    // totalCount: -1
};
function assetsReducerState(state, action) {
    if (state === void 0) { state = exports.initialState; }
    return immer_1.default(state, function (draft) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        // eslint-disable-next-line default-case
        switch (action.type) {
            /**
             * Clear (not delete) all assets.
             * This is currently fired when changing browser filters / views, etc.
             * (May also be useful if we want more traditional paginated browsing, e.g going between pages
             * which doesn't persist content).
             */
            case AssetsActionTypes.CLEAR:
                draft.allIds = [];
                draft.byIds = {};
                break;
            /**
             * An asset has been successfully deleted via the client.
             * - Delete asset from the redux store (both the normalised object and ordered assetID).
             */
            case AssetsActionTypes.DELETE_COMPLETE: {
                var assetId = (_b = (_a = action.payload) === null || _a === void 0 ? void 0 : _a.asset) === null || _b === void 0 ? void 0 : _b._id;
                var deleteIndex = draft.allIds.indexOf(assetId);
                draft.allIds.splice(deleteIndex, 1);
                delete draft.byIds[assetId];
                // draft.totalCount -= 1
                break;
            }
            /**
             * An asset was unable to be deleted via the client.
             * - Store the error code on asset in question to optionally display to the user.
             * - Clear updating status on asset in question.
             */
            case AssetsActionTypes.DELETE_ERROR: {
                var assetId = (_d = (_c = action.payload) === null || _c === void 0 ? void 0 : _c.asset) === null || _d === void 0 ? void 0 : _d._id;
                var errorCode = (_f = (_e = action.payload) === null || _e === void 0 ? void 0 : _e.error) === null || _f === void 0 ? void 0 : _f.statusCode;
                draft.byIds[assetId].errorCode = errorCode;
                draft.byIds[assetId].updating = false;
                break;
            }
            /**
             * A request to delete an asset has been made (and not yet completed).
             * - Set updating status on asset in question.
             * - Clear any existing asset errors
             */
            case AssetsActionTypes.DELETE_REQUEST: {
                var assetId = (_h = (_g = action.payload) === null || _g === void 0 ? void 0 : _g.asset) === null || _h === void 0 ? void 0 : _h._id;
                draft.byIds[assetId].updating = true;
                Object.keys(draft.byIds).forEach(function (key) {
                    delete draft.byIds[key].errorCode;
                });
                break;
            }
            /**
             * A request to fetch assets has succeeded.
             * - Add all fetched assets as normalised objects, and store asset IDs in a separate ordered array.
             */
            case AssetsActionTypes.FETCH_COMPLETE: {
                var assets = ((_j = action.payload) === null || _j === void 0 ? void 0 : _j.assets) || [];
                // const totalCount = action.payload?.totalCount
                if (assets) {
                    assets.forEach(function (asset) {
                        draft.allIds.push(asset._id);
                        draft.byIds[asset._id] = {
                            asset: asset,
                            picked: false,
                            updating: false
                        };
                    });
                }
                draft.fetching = false;
                draft.fetchCount = assets.length || 0;
                draft.fetchingError = null;
                // draft.totalCount = totalCount
                break;
            }
            /**
             * A request to fetch assets has failed.
             * - Clear fetching status
             * - Store error status
             */
            case AssetsActionTypes.FETCH_ERROR: {
                draft.fetching = false;
                draft.fetchingError = true;
                break;
            }
            /**
             * A request to fetch asset has been made (and not yet completed)
             * - Set fetching status
             * - Clear any previously stored error
             */
            case AssetsActionTypes.FETCH_REQUEST:
                draft.fetching = true;
                draft.fetchingError = null;
                break;
            case AssetsActionTypes.LOAD_NEXT_PAGE:
                draft.pageIndex += 1;
                break;
            /**
             * An asset as 'picked' or 'checked' for batch operations.
             * (We don't use the word 'select' as that's reserved for the action of inserting an image into an entry).
             * - Set picked status for asset in question
             */
            case AssetsActionTypes.PICK: {
                var assetId = (_k = action.payload) === null || _k === void 0 ? void 0 : _k.assetId;
                var picked = (_l = action.payload) === null || _l === void 0 ? void 0 : _l.picked;
                draft.byIds[assetId].picked = picked;
                break;
            }
            /**
             * All assets have been picked.
             */
            case AssetsActionTypes.PICK_ALL:
                Object.keys(draft.byIds).forEach(function (key) {
                    draft.byIds[key].picked = true;
                });
                break;
            /**
             * All assets have been unpicked.
             */
            case AssetsActionTypes.PICK_CLEAR:
                Object.keys(draft.byIds).forEach(function (key) {
                    draft.byIds[key].picked = false;
                });
                break;
            case AssetsActionTypes.SET_FILTER:
                draft.filter = (_m = action.payload) === null || _m === void 0 ? void 0 : _m.filter;
                draft.pageIndex = 0;
                break;
            case AssetsActionTypes.SET_ORDER:
                draft.order = (_o = action.payload) === null || _o === void 0 ? void 0 : _o.order;
                draft.pageIndex = 0;
                break;
            case AssetsActionTypes.SET_SEARCH_QUERY:
                draft.searchQuery = (_p = action.payload) === null || _p === void 0 ? void 0 : _p.searchQuery;
                draft.pageIndex = 0;
                break;
            case AssetsActionTypes.SET_VIEW:
                draft.view = (_q = action.payload) === null || _q === void 0 ? void 0 : _q.view;
                break;
        }
    });
}
exports.default = assetsReducerState;
/*******************
 * ACTION CREATORS *
 *******************/
// Clear all assets
exports.assetsClear = function () { return ({
    type: AssetsActionTypes.CLEAR
}); };
// Delete started
exports.assetsDelete = function (asset, handleTarget) {
    if (handleTarget === void 0) { handleTarget = 'snackbar'; }
    return ({
        payload: {
            asset: asset,
            handleTarget: handleTarget
        },
        type: AssetsActionTypes.DELETE_REQUEST
    });
};
// Delete success
exports.assetsDeleteComplete = function (asset) { return ({
    payload: {
        asset: asset
    },
    type: AssetsActionTypes.DELETE_COMPLETE
}); };
// Delete error
exports.assetsDeleteError = function (asset, error, handleTarget) { return ({
    payload: {
        asset: asset,
        handleTarget: handleTarget,
        error: error
    },
    type: AssetsActionTypes.DELETE_ERROR
}); };
// Delete all picked assets
exports.assetsDeletePicked = function () { return ({
    type: AssetsActionTypes.DELETE_PICKED
}); };
/**
 * Start fetch with constructed GROQ query
 *
 * @param {Object} [options]
 * @param {String} [options.filter] - GROQ filter
 * @param {Object} [options.params] - Params to pass to GROQ query (in `client.fetch`)
 * @param {String} [options.projections] - GROQ projections (must be wrapped in braces)
 * @param {String} [options.selector] - GROQ selector / range
 * @param {String} [options.sort] - GROQ sort
 */
exports.assetsFetch = function (_a) {
    var _b = _a.filter, filter = _b === void 0 ? groq_1.default(templateObject_1 || (templateObject_1 = __makeTemplateObject(["_type == \"sanity.imageAsset\""], ["_type == \"sanity.imageAsset\""]))) : _b, _c = _a.params, params = _c === void 0 ? {} : _c, _d = _a.projections, projections = _d === void 0 ? groq_1.default(templateObject_2 || (templateObject_2 = __makeTemplateObject(["{\n    _id,\n    metadata {dimensions},\n    originalFilename,\n    url\n  }"], ["{\n    _id,\n    metadata {dimensions},\n    originalFilename,\n    url\n  }"]))) : _d, _e = _a.selector, selector = _e === void 0 ? "" : _e, _f = _a.sort, sort = _f === void 0 ? groq_1.default(templateObject_3 || (templateObject_3 = __makeTemplateObject(["order(_updatedAt desc)"], ["order(_updatedAt desc)"]))) : _f;
    var pipe = sort || selector ? '|' : '';
    // Construct query
    var query = groq_1.default(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n    {\n      \"items\": *[", "] ", " ", " ", " ", ",\n    }\n  "], ["\n    {\n      \"items\": *[", "] ", " ", " ", " ", ",\n    }\n  "])), filter, projections, pipe, sort, selector);
    return {
        payload: {
            params: params,
            query: query
        },
        type: AssetsActionTypes.FETCH_REQUEST
    };
};
// Fetch complete
exports.assetsFetchComplete = function (assets
// totalCount: number
) { return ({
    payload: {
        assets: assets
        // totalCount
    },
    type: AssetsActionTypes.FETCH_COMPLETE
}); };
// Fetch failed
exports.assetsFetchError = function (error) { return ({
    payload: {
        error: error
    },
    type: AssetsActionTypes.FETCH_ERROR
}); };
// Load page assets at page index
exports.assetsLoadPageIndex = function (pageIndex) { return ({
    payload: {
        pageIndex: pageIndex
    },
    type: AssetsActionTypes.LOAD_PAGE_INDEX
}); };
// Load next page
exports.assetsLoadNextPage = function () { return ({
    type: AssetsActionTypes.LOAD_NEXT_PAGE
}); };
// Pick asset
exports.assetsPick = function (assetId, picked) { return ({
    payload: {
        assetId: assetId,
        picked: picked
    },
    type: AssetsActionTypes.PICK
}); };
// Pick all assets
exports.assetsPickAll = function () { return ({
    type: AssetsActionTypes.PICK_ALL
}); };
// Unpick all assets
exports.assetsPickClear = function () { return ({
    type: AssetsActionTypes.PICK_CLEAR
}); };
// Set view mode
exports.assetsSetView = function (view) { return ({
    payload: {
        view: view
    },
    type: AssetsActionTypes.SET_VIEW
}); };
// Set filter
exports.assetsSetFilter = function (filter) { return ({
    payload: {
        filter: filter
    },
    type: AssetsActionTypes.SET_FILTER
}); };
// Set order
exports.assetsSetOrder = function (order) { return ({
    payload: {
        order: order
    },
    type: AssetsActionTypes.SET_ORDER
}); };
// Set search query
exports.assetsSetSearchQuery = function (searchQuery) { return ({
    payload: {
        searchQuery: searchQuery
    },
    type: AssetsActionTypes.SET_SEARCH_QUERY
}); };
/*********
 * EPICS *
 *********/
/**
 * List for asset delete requests:
 * - make async call to `client.delete`
 * - return a corresponding success or error action
 */
exports.assetsDeleteEpic = function (action$) {
    return action$.pipe(redux_observable_1.ofType(AssetsActionTypes.DELETE_REQUEST), operators_1.mergeMap(function (action) {
        return rxjs_1.of(action).pipe(operators_1.mergeMap(function () {
            var _a, _b;
            var assetId = (_b = (_a = action.payload) === null || _a === void 0 ? void 0 : _a.asset) === null || _b === void 0 ? void 0 : _b._id;
            return rxjs_1.from(client_1.default.delete(assetId));
        }), operators_1.mergeMap(function () {
            var _a;
            var asset = (_a = action.payload) === null || _a === void 0 ? void 0 : _a.asset;
            return rxjs_1.of(exports.assetsDeleteComplete(asset));
        }), operators_1.catchError(function (error) {
            var _a, _b;
            var asset = (_a = action.payload) === null || _a === void 0 ? void 0 : _a.asset;
            var handleTarget = (_b = action.payload) === null || _b === void 0 ? void 0 : _b.handleTarget;
            return rxjs_1.of(exports.assetsDeleteError(asset, error, handleTarget));
        }));
    }));
};
/**
 * Listen for requests to delete all picked assets:
 * - get all picked items not already in the process of updating
 * - invoke delete action creator for all INDIVIDUAL assets
 */
exports.assetsDeletePickedEpic = function (action$, state$) {
    return action$.pipe(redux_observable_1.ofType(AssetsActionTypes.DELETE_PICKED), operators_1.withLatestFrom(state$), operators_1.mergeMap(function (_a) {
        var state = _a[1];
        var availableItems = Object.entries(state.assets.byIds).filter(function (_a) {
            var value = _a[1];
            return value.picked && !value.updating;
        });
        if (availableItems.length === 0) {
            return rxjs_1.empty();
        }
        var assets = availableItems.map(function (item) { return item[1].asset; });
        return rxjs_1.of(assets);
    }), operators_1.mergeAll(), operators_1.mergeMap(function (asset) { return rxjs_1.of(exports.assetsDelete(asset, 'snackbar')); }));
};
/**
 * Listen for fetch requests:
 * - make async call to `client.fetch`
 * - return a corresponding success or error action
 */
exports.assetsFetchEpic = function (action$) {
    return action$.pipe(redux_observable_1.ofType(AssetsActionTypes.FETCH_REQUEST), operators_1.switchMap(function (action) {
        return rxjs_1.of(action).pipe(operators_1.mergeMap(function () {
            var _a, _b;
            var params = (_a = action.payload) === null || _a === void 0 ? void 0 : _a.params;
            var query = (_b = action.payload) === null || _b === void 0 ? void 0 : _b.query;
            return rxjs_1.from(client_1.default.fetch(query, params));
        }), operators_1.mergeMap(function (result) {
            var items = result.items
            // totalCount
            ;
            return rxjs_1.of(exports.assetsFetchComplete(items));
        }), operators_1.catchError(function (error) { return rxjs_1.of(exports.assetsFetchError(error)); }));
    }));
};
/**
 * Listen for page load requests
 * - Fetch assets
 */
exports.assetsFetchPageIndexEpic = function (action$, state$) {
    return action$.pipe(redux_observable_1.ofType(AssetsActionTypes.LOAD_PAGE_INDEX), operators_1.withLatestFrom(state$), operators_1.switchMap(function (_a) {
        var _b;
        var action = _a[0], state = _a[1];
        var pageSize = state.assets.pageSize;
        var start = action.payload.pageIndex * pageSize;
        var end = start + pageSize;
        return rxjs_1.of(exports.assetsFetch(__assign(__assign({ filter: constructFilter(state.assets.filter.value, state.assets.searchQuery) }, ((state === null || state === void 0 ? void 0 : state.document) ? { params: { documentId: (_b = state === null || state === void 0 ? void 0 : state.document) === null || _b === void 0 ? void 0 : _b._id } } : {})), { projections: groq_1.default(templateObject_5 || (templateObject_5 = __makeTemplateObject(["{\n            _id,\n            _updatedAt,\n            extension,\n            metadata {\n              dimensions,\n              isOpaque,\n            },\n            originalFilename,\n            size,\n            url\n          }"], ["{\n            _id,\n            _updatedAt,\n            extension,\n            metadata {\n              dimensions,\n              isOpaque,\n            },\n            originalFilename,\n            size,\n            url\n          }"]))), selector: groq_1.default(templateObject_6 || (templateObject_6 = __makeTemplateObject(["[", "...", "]"], ["[", "...", "]"])), start, end), sort: groq_1.default(templateObject_7 || (templateObject_7 = __makeTemplateObject(["order(", ")"], ["order(", ")"])), state.assets.order.value) })));
    }));
};
/**
 * Listen for changes to order, filter and search query
 * - Clear assets
 * - Load first page
 */
exports.assetsFetchNextPageEpic = function (action$, state$) {
    return action$.pipe(redux_observable_1.ofType(AssetsActionTypes.LOAD_NEXT_PAGE), operators_1.withLatestFrom(state$), operators_1.switchMap(function (_a) {
        var _ = _a[0], state = _a[1];
        return rxjs_1.of(exports.assetsLoadPageIndex(state.assets.pageIndex));
    }));
};
/**
 * Listen for order, filter and search query changes
 * - clear assets
 * - fetch first page
 */
exports.assetsFetchPageEpic = function (action$) {
    return action$.pipe(redux_observable_1.ofType(AssetsActionTypes.SET_ORDER, AssetsActionTypes.SET_FILTER, AssetsActionTypes.SET_SEARCH_QUERY), operators_1.switchMap(function () {
        return rxjs_1.of(exports.assetsClear(), exports.assetsLoadPageIndex(0));
    }));
};
/*********
 * UTILS *
 *********/
/**
 * Construct GROQ filter based off custom search codes
 */
var constructFilter = function (baseFilter, searchQuery) {
    var _a, _b;
    var constructedQuery = groq_1.default(templateObject_8 || (templateObject_8 = __makeTemplateObject(["", ""], ["", ""])), baseFilter);
    var REGEX_ORIENTATION = /orientation:(landscape|portrait|square)/i;
    var REGEX_EXTENSION = /extension:([A-Za-z]*)/i;
    if (searchQuery) {
        // Strip extension / orientation codes and trim whitespace
        var filenameQuery = searchQuery
            .replace(REGEX_ORIENTATION, '')
            .replace(REGEX_EXTENSION, '')
            .trim();
        // Append original filename search
        constructedQuery += groq_1.default(templateObject_9 || (templateObject_9 = __makeTemplateObject([" && originalFilename match '*", "*'"], [" && originalFilename match '*", "*'"
            // Append orientation
        ])), filenameQuery);
        // Append orientation
        var orientation_1 = (_a = searchQuery.match(REGEX_ORIENTATION)) === null || _a === void 0 ? void 0 : _a[1];
        if (orientation_1) {
            switch (orientation_1) {
                case 'landscape':
                    constructedQuery += groq_1.default(templateObject_10 || (templateObject_10 = __makeTemplateObject([" && metadata.dimensions.aspectRatio > 1"], [" && metadata.dimensions.aspectRatio > 1"])));
                    break;
                case 'portrait':
                    constructedQuery += groq_1.default(templateObject_11 || (templateObject_11 = __makeTemplateObject([" && metadata.dimensions.aspectRatio < 1"], [" && metadata.dimensions.aspectRatio < 1"])));
                    break;
                case 'square':
                    constructedQuery += groq_1.default(templateObject_12 || (templateObject_12 = __makeTemplateObject([" && metadata.dimensions.aspectRatio == 1"], [" && metadata.dimensions.aspectRatio == 1"])));
                    break;
                default:
                    console.warn('Orientation must be of type (landscape | portrait | square)');
                    break;
            }
        }
        // Append file extension
        var extension = (_b = searchQuery.match(REGEX_EXTENSION)) === null || _b === void 0 ? void 0 : _b[1];
        if (extension) {
            constructedQuery += groq_1.default(templateObject_13 || (templateObject_13 = __makeTemplateObject([" && extension == '", "'"], [" && extension == '", "'"])), extension);
        }
    }
    return constructedQuery;
};
var templateObject_1, templateObject_2, templateObject_3, templateObject_4, templateObject_5, templateObject_6, templateObject_7, templateObject_8, templateObject_9, templateObject_10, templateObject_11, templateObject_12, templateObject_13;
