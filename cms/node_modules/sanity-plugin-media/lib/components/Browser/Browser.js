"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importStar(require("react"));
var react_redux_1 = require("react-redux");
var react_virtualized_auto_sizer_1 = __importDefault(require("react-virtualized-auto-sizer"));
var react_window_infinite_loader_1 = __importDefault(require("react-window-infinite-loader"));
var useTypedSelector_1 = __importDefault(require("../../hooks/useTypedSelector"));
var assets_1 = require("../../modules/assets");
var Box_1 = __importDefault(require("../../styled/Box"));
var Footer_1 = __importDefault(require("../Footer/Footer"));
var Header_1 = __importDefault(require("../Header/Header"));
var Card_1 = __importDefault(require("../View/Card"));
var Table_1 = __importDefault(require("../View/Table"));
var Browser = function (props) {
    var onClose = props.onClose, selectedAssets = props.selectedAssets;
    // Ref used to scroll to the top of the page on filter changes
    var viewRef = react_1.useRef(null);
    // Redux
    var dispatch = react_redux_1.useDispatch();
    var _a = useTypedSelector_1.default(function (state) { return state.assets; }), allIds = _a.allIds, byIds = _a.byIds, fetchCount = _a.fetchCount, fetching = _a.fetching, pageSize = _a.pageSize, 
    // pageIndex,
    view = _a.view
    // totalCount
    ;
    var currentDocument = useTypedSelector_1.default(function (state) { return state.document; });
    var items = allIds.map(function (id) { return byIds[id]; });
    // const hasFetchedOnce = totalCount >= 0
    var hasFetchedOnce = fetchCount >= 0;
    var hasItems = items.length > 0;
    var picked = items.filter(function (item) { return item.picked; });
    var hasPicked = picked.length > 0;
    // Fetch items on mount
    react_1.useEffect(function () {
        dispatch(assets_1.assetsLoadPageIndex(0));
    }, []);
    // NOTE: The below is a workaround and can be inaccurate in certain cases.
    // e.g. if `pageSize` is 10 and you have fetched 10 items, `hasMore` will still be true
    // and another fetch will invoked on next page (which will return 0 items).
    // This is currently how the default asset source in Sanity works.
    // TODO: When it's performant enough to get total asset count across large datasets, revert
    // to using `totalCount` across the board.
    var hasMore = fetchCount === pageSize;
    // const hasMore = (pageIndex + 1) * pageSize < totalCount
    // Every row is loaded except for our loading indicator row.
    var isItemLoaded = function (index) {
        return index < items.length;
    };
    // Only load 1 page of items at a time.
    // Pass an empty callback to InfiniteLoader in case it asks us to load more than once.
    var handleLoadMoreItems = function () {
        if (!fetching) {
            dispatch(assets_1.assetsLoadNextPage());
        }
        return new Promise(function () { });
    };
    // If there are more items to be loaded then add an extra placeholder row to trigger additional page loads.
    var itemCount = hasMore ? items.length + 1 : items.length;
    return (react_1.default.createElement(Box_1.default, { bg: "darkerGray", fontSize: 1, justifyContent: "space-between", minHeight: "100%" },
        react_1.default.createElement(Header_1.default, { items: items, onClose: onClose }),
        react_1.default.createElement(Box_1.default, { bottom: [hasPicked ? 'headerRowHeight2x' : 0, hasPicked ? 'headerRowHeight' : 0], mx: "auto", overflow: "hidden", position: "absolute", ref: viewRef, top: [
                currentDocument ? 'headerRowHeight3x' : 'headerRowHeight2x',
                currentDocument ? 'headerRowHeight2x' : 'headerRowHeight'
            ], width: "100%" },
            hasItems && (view === 'grid' || 'table') && (react_1.default.createElement(react_virtualized_auto_sizer_1.default, null, function (_a) {
                var height = _a.height, width = _a.width;
                return (react_1.default.createElement(react_window_infinite_loader_1.default, { isItemLoaded: isItemLoaded, itemCount: itemCount, loadMoreItems: handleLoadMoreItems }, function (_a) {
                    var onItemsRendered = _a.onItemsRendered, ref = _a.ref;
                    // View: Table
                    if (view === 'table') {
                        return (react_1.default.createElement(Table_1.default, { height: height, items: items, itemCount: itemCount, onItemsRendered: onItemsRendered, ref: ref, selectedAssets: selectedAssets, width: width }));
                    }
                    // View: Grid
                    if (view === 'grid') {
                        // The `onItemsRendered` method signature for `react-window` grids is different and
                        // requires an adaptor, below.
                        // Source: https://github.com/bvaughn/react-window-infinite-loader/issues/3
                        var newItemsRendered = function (gridData) {
                            var overscanRowStartIndex = gridData.overscanRowStartIndex, overscanRowStopIndex = gridData.overscanRowStopIndex, overscanColumnStopIndex = gridData.overscanColumnStopIndex;
                            var endCol = overscanColumnStopIndex + 1;
                            var startRow = overscanRowStartIndex;
                            var endRow = overscanRowStopIndex;
                            var visibleStartIndex = startRow * endCol;
                            var visibleStopIndex = endRow * endCol;
                            onItemsRendered({
                                overscanStartIndex: visibleStartIndex - 10,
                                overscanStopIndex: visibleStopIndex + 10,
                                visibleStartIndex: visibleStartIndex,
                                visibleStopIndex: visibleStopIndex
                            });
                        };
                        return (react_1.default.createElement(Card_1.default, { height: height, items: items, itemCount: itemCount, onItemsRendered: newItemsRendered, ref: ref, focusedId: picked.length === 1 ? picked[0].asset._id : undefined, selectedAssets: selectedAssets, width: width }));
                    }
                }));
            })),
            !hasItems && hasFetchedOnce && !fetching && (react_1.default.createElement(Box_1.default, { fontSize: 1, p: 3, textColor: "lighterGray" }, "No results for the current query"))),
        hasPicked && react_1.default.createElement(Footer_1.default, null)));
};
exports.default = Browser;
